# ============================================================
# app/utils/file_upload.py
#
# Handles file uploads to Supabase Storage.
# Used for: bank transfer proof screenshots/PDFs.
#
# Storage bucket structure:
#   payment-proofs/
#     {school_id}/
#       {payment_id}/
#         proof.{ext}      ← uploaded by parent/bursar
#
# receipts/
#     {school_id}/
#       {receipt_number}.pdf   ← generated by SchoolPay
#
# Security:
#   Buckets are PRIVATE — files are accessed via signed URLs
#   (expire after 1 hour) not public permanent links.
#   This means even if someone guesses a file path, they
#   can't access it without a valid signed URL.
#
# Why Supabase Storage?
#   - Already in your stack (no additional service)
#   - Private buckets with row-level access control
#   - Signed URLs for temporary access
#   - Free tier: 1GB
# ============================================================

import mimetypes
import logging
from typing import Optional

from fastapi import UploadFile, HTTPException
from app.core.database import supabase_admin
from app.core.config import settings

logger = logging.getLogger(__name__)

PROOF_BUCKET   = "payment-proofs"
RECEIPT_BUCKET = "receipts"

ALLOWED_MIME_TYPES = {
    "image/jpeg":       "jpg",
    "image/png":        "png",
    "image/webp":       "webp",
    "application/pdf":  "pdf",
}

MAX_FILE_BYTES = settings.MAX_FILE_SIZE_MB * 1024 * 1024  # e.g. 5MB


async def upload_transfer_proof(
    file: UploadFile,
    school_id: str,
    payment_id: str,
) -> str:
    """
    Uploads a bank transfer proof file to Supabase Storage.
    Returns the storage path (not a URL — use get_proof_url() to get a URL).

    Validates:
    - File type (JPEG, PNG, WebP, PDF only)
    - File size (max 5MB by default)

    Called from: POST /payments/transfer/proof
    """
    # Validate content type
    content_type = file.content_type or ""
    if content_type not in ALLOWED_MIME_TYPES:
        raise HTTPException(
            status_code=400,
            detail=f"Invalid file type: {content_type}. "
                   f"Allowed: JPEG, PNG, WebP, PDF."
        )

    ext = ALLOWED_MIME_TYPES[content_type]

    # Read file and validate size
    file_bytes = await file.read()
    if len(file_bytes) > MAX_FILE_BYTES:
        raise HTTPException(
            status_code=400,
            detail=f"File too large. Maximum size: {settings.MAX_FILE_SIZE_MB}MB."
        )

    if len(file_bytes) == 0:
        raise HTTPException(status_code=400, detail="File is empty.")

    # Storage path: payment-proofs/{school_id}/{payment_id}/proof.jpg
    storage_path = f"{school_id}/{payment_id}/proof.{ext}"

    try:
        supabase_admin.storage.from_(PROOF_BUCKET).upload(
            path=storage_path,
            file=file_bytes,
            file_options={
                "content-type": content_type,
                "upsert": "true",   # Allow re-upload (parent correcting a wrong file)
            },
        )
        logger.info(f"Uploaded proof for payment {payment_id}: {storage_path}")
        return storage_path

    except Exception as e:
        logger.error(f"Storage upload failed for payment {payment_id}: {e}")
        raise HTTPException(
            status_code=502,
            detail="File upload failed. Please try again."
        )


async def get_proof_signed_url(storage_path: str, expires_in: int = 3600) -> Optional[str]:
    """
    Returns a temporary signed URL for viewing a proof file.
    expires_in: seconds until the URL expires (default 1 hour).

    Used by: bursar approval page to show the proof image/PDF.
    """
    if not storage_path:
        return None
    try:
        result = supabase_admin.storage.from_(PROOF_BUCKET).create_signed_url(
            path=storage_path,
            expires_in=expires_in,
        )
        return result.get("signedURL") or result.get("signed_url")
    except Exception as e:
        logger.error(f"Failed to create signed URL for {storage_path}: {e}")
        return None


async def upload_receipt_pdf(
    pdf_bytes: bytes,
    school_id: str,
    receipt_number: str,
) -> str:
    """
    Uploads a generated PDF receipt to Supabase Storage.
    Returns the storage path.

    The receipt is stored permanently — parents can re-download
    if they lose the original.

    Called from: receipt download endpoint after generating PDF.
    """
    # receipt_number format: RCP/2025/000042 → sanitise for path
    safe_name = receipt_number.replace("/", "-")
    storage_path = f"{school_id}/{safe_name}.pdf"

    try:
        supabase_admin.storage.from_(RECEIPT_BUCKET).upload(
            path=storage_path,
            file=pdf_bytes,
            file_options={
                "content-type": "application/pdf",
                "upsert": "true",
            },
        )
        return storage_path
    except Exception as e:
        logger.error(f"Receipt upload failed ({receipt_number}): {e}")
        # Non-fatal — we can still stream the PDF directly
        return ""


async def get_receipt_signed_url(storage_path: str, expires_in: int = 86400) -> Optional[str]:
    """
    Returns a signed URL for downloading a stored receipt PDF.
    expires_in: 24 hours by default (long — so SMS receipt links stay valid).
    """
    if not storage_path:
        return None
    try:
        result = supabase_admin.storage.from_(RECEIPT_BUCKET).create_signed_url(
            path=storage_path,
            expires_in=expires_in,
        )
        return result.get("signedURL") or result.get("signed_url")
    except Exception as e:
        logger.error(f"Failed to create receipt URL for {storage_path}: {e}")
        return None
